package VCB::Test;
use strict;
use warnings;
use base 'Exporter';
our @EXPORT = qw/
	spin_app_ok
	use_cache_ok

	whoami
	iam_anonymous
	iam

	login_fails
	login_ok

	logout_ok

	ingest_ok

	sets
	set_is

	have_set
	dont_have_set

	validate_fails
	validate_ok

	timeline
	buy_ok
/;

use File::Temp qw/ tempdir /;
use JSON qw/ from_json
             to_json /;

use Test::More ();
use Plack::Test;

my $T = Test::More->builder;
my $ROOT;
my $APP;
my $SID;

sub _put {
	my ($path, $contents) = @_;
	open my $fh, ">", $path
		or die "Failed to create $path: $!\n";
	print $fh $contents;
	close $fh;
	return 1;
}

sub _r {
	my $req = HTTP::Request->new(@_);
	$req->header(Cookie => "vcb_sesh=$SID") if $SID;
	return $req;
}

sub _rp {
	my ($method, $url, $object) = @_;
	return $object
		? _r($method => $url,
		    [Content_Type => 'application/json',
		     Accept       => 'application/json'],
		    to_json($object))
		: _r($method => $url,
		    [Accept       => 'application/json']);
}

sub GET {
	my ($url, $headers) = @_;
	return _r(GET => $url, $headers || []);
}

sub PUT   { return _rp(PUT   => @_); }
sub POST  { return _rp(POST  => @_); }
sub PATCH { return _rp(PATCH => @_); }

sub DELETE {
	my ($url, $headers) = @_;
	return _r(DELETE => $url, $headers || []);
}

sub _follow {
	my ($res) = @_;
	while ($res->is_redirect) {
		$res = _request(GET $res->header('Location'));
	}
	return $res;
}

sub _request {
	my ($req) = @_;
	my $res = $APP->request($req);
	my $h = $res->header('Set-Cookie');
	# vcb_sesh=xAxbnVEFareNebXbeDnalUejYGRmNQgOylJZMqgYoMmYxeoXwqIdosBGzkDinRPHO; Path=/; Expires=Sun, 29-Sep-2019 11:33:58 GMT; SameSite=Strict; HttpOnly
	$SID = $1 if $h && $h =~ m/^vcb_sesh=(.*?);/;
	return $res;
}

sub spin_app_ok {
	my ($note) = @_;
	$note ||= "the VCP::API application should spin up";

	local $@;
	eval {
		$ROOT = tempdir(CLEANUP => 1);
		mkdir("$ROOT/environments");
		_put("$ROOT/environments/test.yml", <<EOF);
---
# this configuration auto-generated by spin_app_ok()
vcb:
  imgroot:   //vault-of-cardboard.s3.amazonaws.com
  cacheroot: $ROOT/cache
plugins:
  DBIC:
    default:
      dsn: dbi:SQLite:dbname=$ROOT/test.db
      schema_class: VCB::DB
EOF

		unlink("test.db");
		local $ENV{DANCER_ENVIRONMENT} = 'test';
		local $ENV{DANCER_CONFDIR} = $ROOT;
		local $ENV{DANCER_ENVDIR}  = "$ROOT/environments";

		local $ENV{VCB_FAILSAFE_USERNAME} = 'urza';
		local $ENV{VCB_FAILSAFE_PASSWORD} = '$2a$12$gVWeTxwtfA5rpM.rj3bQqO$db1ab87bed231995c2b0c275379bb3bafcd12cb4b97474';


		require 'VCB/API.pm';
		$APP = Plack::Test->create(VCB::API->to_app);
	};
	if ($@) {
		$T->ok(0, $note);
		chomp($@);
		$T->diag("encountered unhandled exception '$@'");
		return undef;
	}

	$ENV{VCB_NO_SCRYFALL} = 'yes';
	return $T->ok(1, $note);
}

sub use_cache_ok {
	my ($local, $note) = @_;
	$note ||= "should be able to use '$local' as a cache";

	$ROOT or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	system("cp -a $local $ROOT/cache >/dev/null");
	return $T->ok($? == 0, $note);
}

sub whoami {
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(GET '/v/whoami', [Accept => 'application/json']);
	return from_json($res->decoded_content);
}

sub iam_anonymous {
	my ($note) = @_;
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $id = whoami;
	if (scalar keys %$id != 0) {
		$T->ok(0, $note);
		$T->diag("/v/whoami returned body payload:");
		$T->diag($T->explain($id));
		return undef;
	}
	return $T->ok(1, $note);
}

sub iam {
	my ($want, $note) = @_;
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $id = whoami;
	for my $k (keys %$want) {
		my $got = $id->{$k} || '';
		if ($got ne $want->{$k}) {
			return $T->is_eq($got, $want->{$k}, $note);
		}
	}
	return $T->ok(1, $note);
}

sub login {
	my ($user, $pass) = @_;
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return 0, undef;
	};

	my $req = POST('/v/login', { username => $user,
	                             password => $pass });
	my $res = _request($req);
	return $res->is_success,
	       from_json($res->decoded_content);
}

sub login_fails {
	my ($user, $pass, $note) = @_;
	$note ||= "should not be able to login as [$user:$pass]";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my ($ok, $res) = login $user, $pass;
	if ($ok) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	return $T->ok(1, $note);
}

sub login_ok {
	my ($user, $pass, $note) = @_;
	$note ||= "should be able to login as [$user:$pass]";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my ($ok, $res) = login $user, $pass;
	if (!$ok) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	if ($res->{ok} !~ m/successfully/i) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	return $T->ok(1, $note);
}

sub logout_ok {
	my ($note) = @_;
	$note ||= "should be able to logout";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(POST '/v/logout');
	if (!$res->is_success) {
		$T->ok(0, $note);
		$T->diag("/v/logout returned body payload:");
		$T->diag($res->decoded_content);
		return undef;
	}
	return $T->ok(1, $note);
}

sub ingest_ok {
	my ($code, $note) = @_;
	$note ||= "should be able to ingest set [$code]";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(POST "/v/admin/sets/$code/ingest");
	if (!$res->is_success) {
		$T->ok(0, $note);
		$T->diag("/v/admin/sets/$code/ingest failed:");
		$T->diag($res->as_string);
	}

	return $T->ok(1, $note);
}

sub sets {
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(GET '/sets.json', [Accept => 'application/json']);
	return from_json($res->decoded_content);
}

sub set_is {
	my ($code, $want, $note) = @_;
	$code = uc($code);
	$note ||= "set [$code] should match ".to_json($want);
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $sets = sets || [];
	for (@$sets) {
		next unless $_->{code} eq $code;
		for my $k (keys %$want) {
			return $T->is_eq($_->{$k}, $want->{$k}, $note)
				if $want->{$k} ne $_->{$k};
		}
		return $T->ok(1, $note);
	}

	$T->ok(0, $note);
	$T->diag("set [$code] not found in ".(scalar @$sets)." ingested sets");
	return undef;
}

sub have_set {
	my ($code, $note) = @_;
	$code = uc($code);
	$note ||= "should have set [$code] in the database";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $sets = sets || [];
	for (@$sets) {
		return $T->ok(1, $note)
			if $_->{code} eq $code;
	}

	$T->ok(0, $note);
	$T->diag("set [$code] not found in ".(scalar @$sets)." ingested sets");
	return undef;
}

sub dont_have_set {
	my ($code, $note) = @_;
	$code = uc($code);
	$note ||= "should not have set [$code] in the database";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $sets = sets || [];
	for (@$sets) {
		next unless $_->{code} eq $code;
		$T->ok(0, $note);
		$T->diag("found set [$code]:");
		$T->diag($T->explain($_));
		return undef;
	}

	return $T->ok(1, $note);
}

sub validate {
	my ($vif) = @_;

	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(POST '/v/import/validate', { vif => $vif });
	return from_json($res->decoded_content);
}

sub validate_fails {
	my ($vif, $note) = @_;
	$note ||= "should fail to validate import vif";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $r = validate($vif);
	if ($r->{ok}) {
		$T->ok(0, $note);
		$T->diag("/v/import/validate returned body payload:");
		$T->diag($T->explain($r));
		return undef;
	}

	return $T->ok(1, $note);
}

sub validate_ok {
	my ($vif, $note) = @_;
	$note ||= "should validate import vif ok";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $r = validate($vif);
	if ($r->{error}) {
		$T->ok(0, $note);
		$T->diag("/v/import/validate returned body payload:");
		$T->diag($T->explain($r));
		return undef;
	}

	return $T->ok(1, $note);
}

sub timeline {
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _follow(_request(GET '/my/timeline'));
	return from_json($res->decoded_content);
}

sub buy_ok {
	my ($vif, $note) = @_;
	$note ||= "should be able to add cards to the collection via a BUY";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(POST '/my/changes', {
		raw_gain    => $vif,
		occurred_at => time(),
		type        => 'buy',
		summary     => "A BUY operation",
		notes       => "This BUY was created by a test",
	});
	if (!$res->is_success) {
		$T->ok(0, $note);
		$T->diag("/my/changes returned body payload:");
		$T->diag($res->decoded_content);
		return undef;
	}
	return $T->ok(1, $note);
}

1;

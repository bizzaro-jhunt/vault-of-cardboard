package VCB::Test;
use strict;
use warnings;
use base 'Exporter';
our @EXPORT = qw/
	spin_app_ok

	whoami
	iam_anonymous
	iam

	login_fails
	login_ok

	logout_ok
/;

use File::Temp qw/ tempdir /;
use JSON qw/ from_json
             to_json /;

use Test::More ();
use Plack::Test;

my $T = Test::More->builder;
my $ROOT;
my $APP;
my $SID;

sub _put {
	my ($path, $contents) = @_;
	open my $fh, ">", $path
		or die "Failed to create $path: $!\n";
	print $fh $contents;
	close $fh;
	return 1;
}

sub _r {
	my $req = HTTP::Request->new(@_);
	$req->header(Cookie => "vcb_sesh=$SID") if $SID;
	return $req;
}

sub _rp {
	my ($method, $url, $object) = @_;
	return $object
		? _r($method => $url,
		    [Content_Type => 'application/json',
		     Accept       => 'application/json'],
		    to_json($object))
		: _r($method => $url,
		    [Accept       => 'application/json']);
}

sub GET {
	my ($url, $headers) = @_;
	return _r(GET => $url, $headers || []);
}

sub PUT   { return _rp(PUT   => @_); }
sub POST  { return _rp(POST  => @_); }
sub PATCH { return _rp(PATCH => @_); }

sub DELETE {
	my ($url, $headers) = @_;
	return _r(DELETE => $url, $headers || []);
}

sub _request {
	my ($req) = @_;
	my $res = $APP->request($req);
	my $h = $res->header('Set-Cookie');
	# vcb_sesh=xAxbnVEFareNebXbeDnalUejYGRmNQgOylJZMqgYoMmYxeoXwqIdosBGzkDinRPHO; Path=/; Expires=Sun, 29-Sep-2019 11:33:58 GMT; SameSite=Strict; HttpOnly
	$SID = $1 if $h && $h =~ m/^vcb_sesh=(.*?);/;
	return $res;
}

sub spin_app_ok {
	my ($note) = @_;

	local $@;
	eval {
		$ROOT = tempdir(CLEANUP => 1);
		mkdir("$ROOT/environments");
		_put("$ROOT/environments/test.yml", <<EOF);
---
# this configuration auto-generated by spin_app_ok()
vcb:
  imgroot: //vault-of-cardboard.s3.amazonaws.com
plugins:
  DBIC:
    default:
      dsn: dbi:SQLite:dbname=$ROOT/test.db
      schema_class: VCB::DB
EOF

		unlink("test.db");
		local $ENV{DANCER_ENVIRONMENT} = 'test';
		local $ENV{DANCER_CONFDIR} = $ROOT;
		local $ENV{DANCER_ENVDIR}  = "$ROOT/environments";

		local $ENV{VCB_FAILSAFE_USERNAME} = 'urza';
		local $ENV{VCB_FAILSAFE_PASSWORD} = '$2a$12$gVWeTxwtfA5rpM.rj3bQqO$db1ab87bed231995c2b0c275379bb3bafcd12cb4b97474';

		require 'VCB/API.pm';
		$APP = Plack::Test->create(VCB::API->to_app);
	};
	if ($@) {
		$T->ok(0, $note);
		chomp($@);
		$T->diag("encountered unhandled exception '$@'");
		return undef;
	}
	$T->ok(1, $_[0]);
	return 1;
}

sub whoami {
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(GET '/v/whoami', [Accept => 'application/json']);
	return from_json($res->decoded_content);
}

sub iam_anonymous {
	my ($note) = @_;
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $id = whoami;
	if (scalar keys %$id != 0) {
		$T->ok(0, $note);
		$T->diag("/v/whoami returned body payload:");
		$T->diag($T->explain($id));
		return undef;
	}
	return $T->ok(1, $note);
}

sub iam {
	my ($want, $note) = @_;
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $id = whoami;
	for my $k (keys %$want) {
		my $got = $id->{$k} || '';
		if ($got ne $want->{$k}) {
			return $T->is_eq($got, $want->{$k}, $note);
		}
	}
	return $T->ok(1, $note);
}

sub login {
	my ($user, $pass) = @_;
	$APP or do {
		$T->diag("the VCB::API has not been spun up yet");
		return 0, undef;
	};

	my $req = POST('/v/login', { username => $user,
	                             password => $pass });
	my $res = _request($req);
	return $res->is_success,
	       from_json($res->decoded_content);
}

sub login_fails {
	my ($user, $pass, $note) = @_;
	$note ||= "should not be able to login as [$user:$pass]";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my ($ok, $res) = login $user, $pass;
	if ($ok) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	return $T->ok(1, $note);
}

sub login_ok {
	my ($user, $pass, $note) = @_;
	$note ||= "should be able to login as [$user:$pass]";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my ($ok, $res) = login $user, $pass;
	if (!$ok) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	if ($res->{ok} !~ m/successfully/i) {
		$T->ok(0, $note);
		$T->diag("/v/login returned body payload:");
		$T->diag($T->explain($res));
		return undef;
	}
	return $T->ok(1, $note);
}

sub logout_ok {
	my ($note) = @_;
	$note ||= "should be able to logout";
	$APP or do {
		$T->ok(0, $note);
		$T->diag("the VCB::API has not been spun up yet");
		return undef;
	};

	my $res = _request(POST '/v/logout');
	if (!$res->is_success) {
		$T->ok(0, $note);
		$T->diag("/v/logout returned body payload:");
		$T->diag($res->decoded_content);
		return undef;
	}
	return $T->ok(1, $note);
}

1;
